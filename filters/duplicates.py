
import os
import os.path
import re
import codecs

from pybtex.database import BibliographyData;


from core.bibfilter import BibFilter, BibFilterError;
from core.blogger import logger;



BIBALIAS_HEADER = ur"""
%
% NOTE: THIS FILE WAS AUTOMATICALLY GENERATED BY bibolamazi SCRIPT!
%       ANY CHANGES WILL BE LOST!
%
% You should include this file in your main LaTeX file with the command
%
%   \input{####DUP_FILE_NAME####}
%
% in your document preamble.
%



%
% The following will define the command \bibalias{<alias>}{<source>}, which will make
% the command \cite[..]{<alias>} the same as doing \cite[..]{<source>}.
%
% This code has been copied and adapted from
%    http://tex.stackexchange.com/questions/37233/
%

\makeatletter
% \bibalias{<alias>}{<source>} makes \cite{<alias>} equivalent to \cite{<source>}
\newcommand\bibalias[2]{%
  \@namedef{bibali@#1}{#2}%
}

\newtoks\biba@toks
\let\bibalias@oldcite\cite
\renewcommand\cite[2][]{%
  \biba@toks{\bibalias@oldcite#1}%
  \def\biba@comma{}%
  \def\biba@all{}%
  \@for\biba@one:=#2\do{%
    \@ifundefined{bibali@\biba@one}{%
      \edef\biba@all{\biba@all\biba@comma\biba@one}%
    }{%
      \PackageInfo{bibalias}{%
        Replacing citation `\biba@one' with `\@nameuse{bibali@\biba@one}'
      }%
      \edef\biba@all{\biba@all\biba@comma\@nameuse{bibali@\biba@one}}%
    }%
    \def\biba@comma{,}%
  }%
  \edef\biba@tmp{\the\biba@toks{\biba@all}}%
  \biba@tmp
}
\makeatother


%
% Now, declare all the alias keys.
%

"""


class DuplicatesFilter(BibFilter):
    
    def __init__(self, dupfile):
        BibFilter.__init__(self);

        self.dupfile = dupfile

        logger.debug('duplicates: dupfile=%r' % dupfile);

    def name(self):
        return "duplicates processing"

    def action(self):
        return BibFilter.BIB_FILTER_BIBFILTERFILE;


    def compare_entries_same(self, a, b):
        apers = a.persons.get('author',[]);
        bpers = b.persons.get('author',[]);
        if (len(apers) != len(bpers)):
            return False

        def getlast(pers):
            # join last names
            last = pers.last()[-1].upper();
            # additionally, remove any special LaTeX chars which may be written differently.
            last = re.sub(r'\\([a-zA-Z]+|.)', '', last);
            last = re.sub(r'(\{|\})', '', last);
            return last;

        for k in range(len(apers)):
            if (not (getlast(apers[k]) == getlast(bpers[k]))):
                return False

        def compare_neq_fld(x, y, fld):
            return x.get(fld, y.get(fld)) != y.get(fld, x.get(fld)) ;

        # authors are the same. check year
        if (compare_neq_fld(a.fields, b.fields, 'year')):
            return False
        if (compare_neq_fld(a.fields, b.fields, 'month')):
            return False

        # create abbreviations of the journals by keeping only the uppercase letters
        j_abbrev_a = re.sub('[^A-Z]', '', a.fields.get('journal', ''));
        j_abbrev_b = re.sub('[^A-Z]', '', b.fields.get('journal', ''));
        if (j_abbrev_a != j_abbrev_b):
            return False

        # well at this point the publications are pretty much duplicates
        return True
        


    def filter_bibfilterfile(self, bibfilterfile):
        #
        # bibdata is a pybtex.database.BibliographyData object
        #

        bibdata = bibfilterfile.bibliographydata();

        duplicates = [];

        newbibdata = BibliographyData();

        for (key, entry) in bibdata.entries.iteritems():
            #
            # search the newbibdata object, in case this entry already exists.
            #
            is_duplicate_of = None
            for (nkey, nentry) in newbibdata.entries.iteritems():
                if self.compare_entries_same(entry, nentry):
                    is_duplicate_of = nkey;
                    break

            #
            # if it's a duplicate
            #
            if is_duplicate_of is not None:
                dup = (key, is_duplicate_of)
                duplicates.append(dup);
            else:
                newbibdata.add_entry(key, entry);

        # output duplicates to the duplicates file

        dupstrlist = [];
        with codecs.open(os.path.join(bibfilterfile.fdir(),self.dupfile), 'w', 'utf-8') as dupf:
            dupf.write(re.sub(r'####DUP_FILE_NAME####', self.dupfile, BIBALIAS_HEADER, 1));
            for (dupalias, duporiginal) in duplicates:
                dupf.write((r'\bibalias{%s}{%s}' % (dupalias, duporiginal)) + "\n");
                dupstrlist.append("\t%s is an alias of %s" % (dupalias,duporiginal)) ;
            
            dupf.write('\n\n');
            
        logger.debug("DUPLICATES: \n" + "\n".join(dupstrlist));


        bibfilterfile.setBibliographyData(newbibdata);

        return


def getclass():
    return DuplicatesFilter;

